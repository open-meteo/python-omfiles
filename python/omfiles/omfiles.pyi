# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import numpy
import numpy.typing
import omfiles
import typing

class OmFilePyReader:
    r"""
    An OmFilePyReader class for reading .om files.
    
    A reader object can have an arbitrary number of child readers, each representing
    a multidimensional variable or a scalar variable (an attribute). Thus, this class
    implements a tree-like structure for multi-dimensional data access.
    
    Variables in OM-Files do not have named dimensions! That means you have to know
    what the dimensions represent in advance or you need to explicitly encode them as
    some kind of attribute.
    
    Most likely we will adopt the xarray convention which is implemented for zarr
    which requires multi-dimensional variables to have an attribute called
    _ARRAY_DIMENSIONS that contains a list of dimension names.
    These dimension names should be encoded somewhere in the .om file hierarchy
    as attributes.
    
    Therefore, it might be useful to differentiate in some way between
    hdf5-like groups and datasets/n-dim arrays in an om-file.
    
    Group: Can contain datasets/arrays, attributes, and other groups.
    Dataset: Data-array, might have associated attributes.
    Attribute: A named data value associated with a group or dataset.
    """
    shape: builtins.list[builtins.int]
    r"""
    Get the shape of the data stored in the .om file.
    
    Returns:
        List containing the dimensions of the data
    """
    closed: builtins.bool
    r"""
    Check if the reader is closed.
    
    Returns:
        True if the reader is closed, False otherwise
    """
    is_scalar: builtins.bool
    r"""
    Check if the variable is a scalar.
    
    Returns:
        True if the variable is a scalar, False otherwise
    """
    is_group: builtins.bool
    r"""
    Check if the variable is a group (a variable with data type None).
    
    Returns:
        True if the variable is a group, False otherwise
    """
    dtype: numpy.dtype
    r"""
    Get the data type of the data stored in the .om file.
    
    Returns:
        Numpy data type of the data
    """
    name: builtins.str
    r"""
    Get the name of the variable stored in the .om file.
    
    Returns:
        Name of the variable or an empty string if not available
    """
    def __new__(cls, source:typing.Any) -> OmFilePyReader:
        r"""
        Initialize an OmFilePyReader from a file path or fsspec file object.
        
        Args:
            source: Path to the .om file to read or a fsspec file object
        
        Raises:
            ValueError: If the file cannot be opened or is invalid
        """
    @staticmethod
    def from_path(file_path:builtins.str) -> OmFilePyReader:
        r"""
        Create an OmFilePyReader from a file path.
        
        Args:
            file_path: Path to the .om file to read
        
        Returns:
            OmFilePyReader instance
        """
    @staticmethod
    def from_fsspec(file_obj:typing.Any) -> OmFilePyReader:
        r"""
        Create an OmFilePyReader from a fsspec file object.
        
        Args:
            file_obj: fsspec file object with read, seek methods and fs attribute
        
        Returns:
            OmFilePyReader instance
        """
    def get_flat_variable_metadata(self) -> builtins.dict[builtins.str, OmVariable]:
        r"""
        Get a mapping of variable names to their file offsets and sizes.
        """
    def init_from_variable(self, variable:OmVariable) -> OmFilePyReader:
        r"""
        Initialize a new OmFilePyReader from a child variable.
        """
    def __enter__(self) -> OmFilePyReader:
        r"""
        Enter a context manager block.
        
        Returns:
            Self for use in context manager
        
        Raises:
            ValueError: If the reader is already closed
        """
    def __exit__(self, _exc_type:typing.Optional[typing.Any]=None, _exc_value:typing.Optional[typing.Any]=None, _traceback:typing.Optional[typing.Any]=None) -> builtins.bool:
        r"""
        Exit a context manager block, closing the reader.
        
        Args:
            _exc_type: The exception type, if an exception was raised
            _exc_value: The exception value, if an exception was raised
            _traceback: The traceback, if an exception was raised
        
        Returns:
            False (exceptions are not suppressed)
        """
    def close(self) -> None:
        r"""
        Close the reader and release resources.
        
        This method releases all resources associated with the reader.
        After closing, any operation on the reader will raise a ValueError.
        
        It is safe to call this method multiple times.
        """
    def __getitem__(self, ranges:omfiles.types.BasicSelection) -> numpy.typing.NDArray[typing.Union[numpy.float32, numpy.float64, numpy.int32, numpy.int64, numpy.uint32, numpy.uint64, numpy.int8, numpy.uint8, numpy.int16, numpy.uint16]]:
        r"""
        Read data from the open variable.om file using numpy-style indexing.
        Currently only slices with step 1 are supported.
        
        The returned array will have singleton dimensions removed (squeezed).
        For example, if you index a 3D array with [1,:,2], the result will
        be a 1D array since dimensions 0 and 2 have size 1.
        
        Args:
            ranges: Index expression that can be either a single slice/integer
                   or a tuple of slices/integers for multi-dimensional access.
                   Supports NumPy basic indexing including:
                   - Integers (e.g., a[1,2])
                   - Slices (e.g., a[1:10])
                   - Ellipsis (...)
                   - None/newaxis
        
        Returns:
            NDArray containing the requested data with squeezed singleton dimensions.
            The data type of the array matches the data type stored in the file
            (int8, uint8, int16, uint16, int32, uint32, int64, uint64, float32, or float64).
        
        Raises:
            ValueError: If the requested ranges are invalid or if there's an error reading the data
        """
    def get_scalar(self) -> typing.Any:
        r"""
        Get the scalar value of the variable.
        
        Returns:
            The scalar value as a Python object (str, int, or float)
        
        Raises:
            ValueError: If the variable is not a scalar
        """

class OmFilePyReaderAsync:
    r"""
    A reader for OM files with async access.
    
    This class provides asynchronous access to multi-dimensional array data stored
    in OM files. It supports reading from local files via memory mapping or
    from remote files through fsspec compatibility.
    """
    shape: builtins.list[builtins.int]
    r"""
    Shape of the array data in the file (read-only property)
    """
    @staticmethod
    async def from_fsspec(fs_obj:typing.Any, path:builtins.str) -> OmFilePyReaderAsync:
        r"""
        Create a new async reader from an fsspec file object.
        
        Parameters
        ----------
        file_obj : fsspec.core.OpenFile
            An fsspec file object with read_bytes method and fs attribute.
        
        Returns
        -------
        OmFilePyReaderAsync
            A new reader instance
        
        Raises
        ------
        TypeError
            If the provided file object is not a valid fsspec file
        IOError
            If there's an error reading the file
        """
    @staticmethod
    async def from_path(file_path:builtins.str) -> OmFilePyReaderAsync:
        r"""
        Create a new async reader from a local file path.
        
        Parameters
        ----------
        file_path : str
            Path to the OM file to read
        
        Returns
        -------
        OmFilePyReaderAsync
            A new reader instance
        
        Raises
        ------
        IOError
            If the file cannot be opened or read
        """
    async def read_concurrent(self, ranges:omfiles.types.BasicSelection) -> numpy.typing.NDArray[typing.Union[numpy.float32, numpy.float64, numpy.int32, numpy.int64, numpy.uint32, numpy.uint64, numpy.int8, numpy.uint8, numpy.int16, numpy.uint16]]:
        r"""
        Read data from the array concurrently based on specified ranges.
        
        Parameters
        ----------
        ranges : ArrayIndex
            Index or slice object specifying the ranges to read
        
        Returns
        -------
        OmFileTypedArray
            Array data of the appropriate numpy type
        
        Raises
        ------
        ValueError
            If the reader is closed
        TypeError
            If the data type is not supported
        """
    def close(self) -> None:
        r"""
        Close the reader and release any resources.
        
        This method properly closes the underlying file resources.
        
        Returns
        -------
        None
        
        Raises
        ------
        RuntimeError
            If the reader cannot be closed due to concurrent access
        """

class OmFilePyWriter:
    r"""
    A Python wrapper for the Rust OmFileWriter implementation.
    """
    closed: builtins.bool
    r"""
    Check if the writer is closed.
    """
    def __new__(cls, file_path:builtins.str) -> OmFilePyWriter:
        r"""
        Initialize an OmFilePyWriter.
        
        Args:
            file_path: Path where the .om file will be created
        
        Raises:
        OSError: If the file cannot be created
        """
    def close(self, root_variable:OmVariable) -> None:
        r"""
        Finalize and close the .om file by writing the trailer with the root variable.
        
        Args:
            root_variable: The OmVariable that serves as the root/entry point of the file hierarchy.
                           All other variables should be accessible through this root variable.
        
        Returns:
            None on success.
        
        Raises:
            ValueError: If the writer has already been closed
            RuntimeError: If a thread lock error occurs or if there's an error writing to the file
        """
    def write_array(self, data:numpy.typing.NDArray[typing.Any], chunks:typing.Sequence[builtins.int], scale_factor:typing.Optional[builtins.float]=None, add_offset:typing.Optional[builtins.float]=None, compression:typing.Optional[builtins.str]=None, name:typing.Optional[builtins.str]=None, children:typing.Optional[typing.Sequence[OmVariable]]=None) -> OmVariable:
        r"""
        Write a numpy array to the .om file with specified chunking and scaling parameters.
        
        Args:
            data: Input array to be written. Supported dtypes are:
                  float32, float64, int8, uint8, int16, uint16, int32, uint32, int64, uint64,
            chunks: Chunk sizes for each dimension of the array
            scale_factor: Scale factor for data compression (default: 1.0)
            add_offset: Offset value for data compression (default: 0.0)
            compression: Compression algorithm to use (default: "pfor_delta_2d")
                         Supported values: "pfor_delta_2d", "fpx_xor_2d", "pfor_delta_2d_int16", "pfor_delta_2d_int16_logarithmic"
            name: Name of the variable to be written (default: "data")
            children: List of child variables (default: [])
        
        Returns:
            OmVariable representing the written group in the file structure
        
        Raises:
            ValueError: If the data type is unsupported or if parameters are invalid
        """
    def write_scalar(self, value:typing.Any, name:builtins.str, children:typing.Optional[typing.Sequence[OmVariable]]=None) -> OmVariable:
        r"""
        Write a scalar value to the .om file.
        
        Args:
            value: Scalar value to write. Supported types are:
                   int8, int16, int32, int64, uint8, uint16, uint32, uint64, float32, float64, String
            name: Name of the scalar variable
            children: List of child variables (default: None)
        
        Returns:
            OmVariable representing the written scalar in the file structure
        
        Raises:
            ValueError: If the value type is unsupported (e.g., booleans)
            RuntimeError: If there's an error writing to the file
        """
    def write_group(self, name:builtins.str, children:typing.Sequence[OmVariable]) -> OmVariable:
        r"""
        Create a new group in the .om file. This is essentially a variable with no data,
        which serves as a container for other variables.
        
        Args:
            name: Name of the group
            children: List of child variables
        
        Returns:
            OmVariable representing the written group in the file structure
        
        Raises:
            RuntimeError: If there's an error writing to the file
        """

class OmVariable:
    r"""
    Represents a variable in an OM file.
    """
    name: builtins.str
    r"""
    The name of the variable.
    """
    offset: builtins.int
    r"""
    The offset of the variable in the OM file.
    """
    size: builtins.int
    r"""
    The size of the variable in bytes in the OM file.
    """
    def __repr__(self) -> builtins.str: ...

